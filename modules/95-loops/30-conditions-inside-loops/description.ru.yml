---
name: Условия внутри тела цикла
theory: |

  Тело цикла, как и тело метода — это место выполнения инструкций. Значит, мы можем использовать внутри него всё изученное ранее, например — условные конструкции.

  Представьте себе метод, который считает, сколько раз входит буква в предложение. Пример его работы:

  ```cs
  App.CountChars("Fear cuts deeper than swords.", 'e'); // 4
  // Если вы ничего не нашли, то результат — 0 совпадений
  App.CountChars("Sansa", 'y'); // 0
  ```

  Перед тем как посмотреть его содержимое, попробуйте ответить на вопросы:

  * Является ли эта операция агрегацией?
  * Какой будет проверка на вхождение символа?

  ```cs
  class App
  {
      public static int CountChars(string str, char ch)
      {
          var i = 0;
          var count = 0;
          while (i < str.Length)
          {
              if (str[i] == ch)
              {
                  // Считаем только подходящие символы
                  count = count + 1;
              }

              // Счетчик увеличивается в любом случае
              i = i + 1;
          }

          return count;
      }
  }
  ```

  Эта задача является агрегирующей. Несмотря на то, что метод считает не все символы, для подсчета самой суммы все равно приходится анализировать каждый символ.

  Ключевое отличие этого цикла от рассмотренных, заключается в наличии условия внутри тела. Переменная `count` увеличивается только в том случае, когда текущий рассматриваемый символ совпадает с ожидаемым.

  В остальном — это типичный агрегатный метод, который возвращает количество нужных символов вызываемому коду.

instructions: |

  Метод из теории учитывает регистр букв. То есть `A` и `a`, с его точки зрения, это разные символы. Реализуйте вариант этого же метода так, чтобы регистр букв был не важен:

  ```cs
  App.CountChars("HexlEt", 'e'); // 2
  App.CountChars("HexlEt", 'E'); // 2
  ```

  * `char.ToLower()` – переводит символ в нижний регистр
